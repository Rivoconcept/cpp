date | value
    2011-01-03 | 3
2011-01-03 | 2
2011-01-03 | 1
2011-01-03 | 1.2
2011-01-09 | 1
2012-01-11 | -1
2001-42-42
2012-01-11 | 1
2012-01-11 | 2147483648


#include "BitcoinExchange.hpp"

BitcoinExchange::BitcoinExchange() : _fileContent(0), _dataBase(0) {}

BitcoinExchange::BitcoinExchange(const BitcoinExchange& other)
{
    *this = other;
}

BitcoinExchange& BitcoinExchange::operator=(const BitcoinExchange& other)
{
    if (this != &other)
    {
        _dataBase = other._dataBase;
    }
    return (*this);
}

BitcoinExchange::~BitcoinExchange() {}

bool BitcoinExchange::isFloatLiteral(const std::string& str)
{
    if (str == "-inff" || str == "+inff" || str == "nanf")
        return true;

    if (str.empty() || str[str.length() - 1] != 'f')
        return false;

    std::string floatPart = str.substr(0, str.length() - 1);
    std::istringstream iss(floatPart);
    double d; 
    char c;

    if (!(iss >> d))
        return false;

    if (!std::isfinite(static_cast<float>(d)))
        return false;

    if (iss >> c)
        return false;

    if (d < -std::numeric_limits<float>::max() || d > std::numeric_limits<float>::max())
        return false;

    return true;
}

void BitcoinExchange::fromFloat(const std::string& literal)
{
    std::istringstream iss(literal);
    double d;

    if (!(iss >> d))
    {
        std::cout << "Conversion to float: impossible" << std::endl;
        return;
    }

    float f = static_cast<float>(d);


    if (std::isnan(f) || f < std::numeric_limits<char>::min() || f > std::numeric_limits<char>::max())
        std::cout << "char: impossible" << std::endl;
    else if (!std::isprint(static_cast<char>(f)))
        std::cout << "char: Non displayable" << std::endl;
    else
        std::cout << "char: '" << static_cast<char>(f) << "'" << std::endl;


    if (f < static_cast<float>(std::numeric_limits<int>::min()) ||
        f > static_cast<float>(std::numeric_limits<int>::max()) ||
        std::isnan(f) || std::isinf(f))
        std::cout << "int: impossible" << std::endl;
    else
        std::cout << "int: " << static_cast<int>(f) << std::endl;

    std::cout << std::fixed << std::setprecision(1);
    if (std::isinf(f) || d < -std::numeric_limits<float>::max() || d > std::numeric_limits<float>::max())
        std::cout << "float: " << (f > 0 ? "+inff" : "-inff") << std::endl;
    else if (std::isnan(f))
        std::cout << "float: nanf" << std::endl;
    else
        std::cout << "float: " << f << "f" << std::endl;
    std::cout << "double: " << d << std::endl;
}

const std::deque<std::string>& BitcoinExchange::getDataBase() const
{
    return (_dataBase);
}

const std::deque<std::string>& BitcoinExchange::getFileContent() const
{
    return (_fileContent);
}

bool BitcoinExchange::isLeapYear(int year) 
{
    if (year % 400 == 0)
        return true;
    if (year % 100 == 0)
        return false;
    if (year % 4 == 0)
        return true;
    return false;
}

bool BitcoinExchange::isValidDate(int year, int month, int day)
{
    if (year < 1 || month < 1 || month > 12 || day < 1)
        return false;

    int days_in_month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    if (month == 2 && isLeapYear(year))
        days_in_month[1] = 29;

    if (day > days_in_month[month - 1])
        return false;

    return true;
}

const std::string& BitcoinExchange::myRegexReplace(std::string& str, const std::string& charsToReplace, char c)
{
    if (str.empty() || charsToReplace.empty())
        return str;

    for (size_t i = 0; i < str.size(); ++i)
    {
        for (size_t j = 0; j < charsToReplace.size(); ++j)
        {
            if (charsToReplace[j] == str[i])
            {
                str[i] = c;
                break;
            }
        }
    }
    return str;
}
std::string BitcoinExchange::removeOtherSpace(const std::string& str)
{
    std::string (result);
    bool inSpace = false;

    for (size_t i = 0; i < str.size(); ++i)
    {
        if (isspace(static_cast<unsigned char>(str[i])))
        {
            if (!inSpace)
            {
                result += ' ';
                inSpace = true;
            }
        }
        else
        {
            result += str[i];
            inSpace = false;
        }
    }
    
    if (!result.empty() && result[0] == ' ')
    {
        result.erase(0, 1);
    }
    
    if (!result.empty() && result[result.size() - 1] == ' ')
    {
        result.erase(result.size() - 1, 1);
    }

    return (result);
}



std::deque<float> BitcoinExchange::ftSplitToFloat(const std::string& str, char delimiter)
{
    std::deque<float> output;
    std::istringstream iss(str);
    std::string token;
    
    while (std::getline(iss, token, delimiter))
    {
        if (!token.empty())
        {
            std::istringstream iss_token(token);
            float n;
            char extra;
            
            if (!(iss_token >> n) || (iss_token >> extra))
                throw std::runtime_error("Token invalide: '" + token + "'");
            
            if (n < std::numeric_limits<int>::min() || n > std::numeric_limits<int>::max())
                throw std::runtime_error("Nombre hors limites: " + token);
            
            output.push_back(static_cast<int>(n));
        }
    }
    
    return (output);
}

void BitcoinExchange::putDataBase(const std::string& fileName)
{
    std::ifstream ifs(fileName.c_str());
    if (!ifs)
    {
        throw std::runtime_error("Error: cannot open file '" + fileName + "'");
    }
    
    std::string line;
    
    while (std::getline(ifs, line))
    {
        _dataBase.push_back(line);
    }
    ifs.close();
}

void BitcoinExchange::putFileContent(const std::string& fileName)
{
    std::ifstream ifs(fileName.c_str());
    if (!ifs)
    {
        throw std::runtime_error("Error: cannot open file '" + fileName + "'");
    }
    
    std::string line;
    
    while (std::getline(ifs, line))
    {
        _fileContent.push_back(line);
    }
    ifs.close();
} 

void BitcoinExchange::findValue(const std::deque<std::string>& dataBase, const std::deque<std::string>& dataFile)
{
    if (dataFile.empty() || dataBase.empty())
        return;
        
    std::string line;
    std::deque<float> tabLine;

    (void)dataBase;

    for (std::deque<std::string>::const_iterator it = dataFile.begin() + 1; it != dataFile.end(); ++it)
    {
        line = *it;
        line = myRegexReplace(line, "-|", ' ');
        line = removeOtherSpace(line);
        
        tabLine = ftSplitToFloat(line, ' ');

        for (std::deque<float>::const_iterator itTabLine = tabLine.begin(); itTabLine != tabLine.end(); ++itTabLine)
        {
            std::cout << *itTabLine << " ";
        }
        std::cout << std::endl;
    }
}



