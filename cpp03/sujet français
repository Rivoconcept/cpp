D'abord, vous devez impl√©menter une classe ! Quelle originalit√© !
Elle s'appellera ClapTrap et aura les attributs priv√©s suivants, initialis√©s aux valeurs sp√©cifi√©es entre parenth√®ses :

Nom, qui est pass√© en param√®tre au constructeur

Points de vie (10), repr√©sentant la sant√© du ClapTrap

Points d'√©nergie (10)

D√©g√¢ts d'attaque (0)

Ajoutez les fonctions membres publiques suivantes afin que le ClapTrap se comporte de mani√®re plus r√©aliste :

void attack(const std::string& target);

void takeDamage(unsigned int amount);

void beRepaired(unsigned int amount);

Lorsqu'un ClapTrap attaque, il fait perdre <d√©g√¢ts d'attaque> points de vie √† sa cible.
Lorsqu'un ClapTrap se r√©pare, il regagne <amount> points de vie.
Chaque attaque et r√©paration co√ªte 1 point d'√©nergie.
Bien entendu, ClapTrap ne peut rien faire s'il n'a plus de points de vie ou d'√©nergie.

Cependant, puisque cet exercice est une introduction, les instances de ClapTrap ne doivent pas interagir
 directement entre elles et les param√®tres ne feront pas r√©f√©rence √† une autre instance de ClapTrap.

Dans chacune de ces fonctions membres, vous devez afficher un message d√©crivant l'action effectu√©e. Par exemple,
 la fonction attack() pourrait afficher quelque chose comme ceci (bien s√ªr, sans les crochets) :

ClapTrap <nom> attaque <cible>, causant <d√©g√¢ts> points de d√©g√¢ts !
Le constructeur et le destructeur doivent √©galement afficher un message afin que vos √©valuateurs puissent facilement voir qu'ils ont √©t√© appel√©s.

Enfin, impl√©mentez et soumettez vos propres tests pour vous assurer que votre code fonctionne comme pr√©vu.

/*********************************************************************************************************************

Comme on n'a jamais assez de ClapTrap, vous allez maintenant cr√©er un robot d√©riv√©.
Il sera nomm√© ScavTrap et h√©ritera des constructeurs et du destructeur de ClapTrap. Cependant, ses constructeurs, son destructeur 
et sa fonction attack() afficheront des messages diff√©rents.
Apr√®s tout, les ClapTrap sont conscients de leur individualit√©.
Notez qu'un encha√Ænement construction/destruction correct doit √™tre d√©montr√© dans vos tests.
Lorsqu'un ScavTrap est cr√©√©, le programme commence par construire un ClapTrap. La destruction se d√©roule dans l'ordre inverse. Pourquoi¬†?
ScavTrap utilisera les attributs de ClapTrap (mettez √† jour ClapTrap en cons√©quence) et
doit les initialiser √†¬†:
‚Ä¢ Nom, pass√© en param√®tre au constructeur
‚Ä¢ Points de vie (100), repr√©sentant la sant√© du ClapTrap
‚Ä¢ Points d'√©nergie (50)
‚Ä¢ D√©g√¢ts d'attaque (20)
ScavTrap aura √©galement sa propre capacit√© sp√©ciale¬†:
void guardGate(); Cette fonction membre affichera un message indiquant que ScavTrap est d√©sormais en mode Gatekeeper.
N'oubliez pas d'ajouter d'autres tests √† votre programme.

/******************************************************************************************************************************************/

Cr√©er des ClapTraps commence probablement √† te taper sur les nerfs.
√Ä pr√©sent, impl√©mente une classe FragTrap qui h√©rite de ClapTrap. Elle est tr√®s similaire √† ScavTrap. Cependant, 
ses messages de construction et de destruction doivent √™tre diff√©rents.

Tu dois montrer clairement l‚Äôencha√Ænement correct des constructions/destructions dans tes tests :

Lorsqu‚Äôun FragTrap est cr√©√©, le programme commence par construire un ClapTrap.

Lors de la destruction, cela se fait dans l‚Äôordre inverse.

Les attributs sont √©galement semblables, mais avec des valeurs diff√©rentes cette fois-ci :

Le nom, qui est pass√© en param√®tre au constructeur

Les points de vie (Hit points) : 100

Les points d‚Äô√©nergie (Energy points) : 100

Les d√©g√¢ts d‚Äôattaque (Attack damage) : 30

La classe FragTrap poss√®de aussi une capacit√© sp√©ciale :


void highFivesGuys(void);



Cette fonction-membre doit afficher une demande de "high-five" (tape m‚Äôen cinq) positive sur la sortie standard.

Encore une fois, ajoute davantage de tests √† ton programme.

Si tu veux, je peux t‚Äôaider √† √©crire la classe FragTrap compl√®te avec les bons messages de log et un test dans le main() 
pour illustrer tout √ßa. Tu veux que je te le fasse ?

/*********************************************************************************************************************************************************/

Dans cet exercice, tu vas cr√©er un monstre : un ClapTrap √† moiti√© FragTrap, √† moiti√© ScavTrap. Il s‚Äôappellera DiamondTrap, 
et il h√©ritera √† la fois de FragTrap ET de ScavTrap. C‚Äôest risqu√© !

La classe DiamondTrap aura un attribut priv√© nomm√© name. Cet attribut doit avoir exactement le m√™me nom de variable que celui 
de la classe de base ClapTrap (sans faire r√©f√©rence au nom du robot).

Pour √™tre plus clair, voici deux exemples :

Si la variable de ClapTrap est name, alors celle de DiamondTrap doit aussi s‚Äôappeler name.

Si la variable de ClapTrap est _name, alors celle de DiamondTrap doit aussi s‚Äôappeler _name.

Ses attributs et fonctions membres seront h√©rit√©s de ses classes parentes :

name (qui est pass√© en param√®tre au constructeur)

ClapTrap::name (c‚Äôest-√†-dire le nom pass√© au constructeur + le suffixe "_clap_name")

Points de vie (h√©rit√©s de FragTrap)

Points d‚Äô√©nergie (h√©rit√©s de ScavTrap)

D√©g√¢ts d‚Äôattaque (h√©rit√©s de FragTrap)

La fonction attack() (h√©rit√©e de ScavTrap)

En plus des fonctions sp√©ciales h√©rit√©es des deux classes parentes, DiamondTrap aura sa propre capacit√© sp√©ciale :

void whoAmI();
Cette fonction membre affichera son propre nom ainsi que le nom de son ClapTrap.

Bien s√ªr, l‚Äôinstance ClapTrap dans DiamondTrap ne sera cr√©√©e qu‚Äôune seule fois.
Oui, il y a un pi√®ge üß†üòâ

Encore une fois, pense √† ajouter des tests √† ton programme.

Souhaites-tu aussi un exemple d‚Äôimpl√©mentation pour DiamondTrap ?