Concevons un cauchemar artificiel fait de bureaux, de couloirs, de formulaires et de files d‚Äôattente.
Amusant, non ? Non ? Tant pis.

Commencez d‚Äôabord par le plus petit rouage de cette vaste machine bureaucratique : le Bureaucrat.

Un Bureaucrat doit avoir :
‚Ä¢ Un nom constant.
‚Ä¢ Une note (grade) allant de 1 (la note la plus √©lev√©e possible) √† 150 (la plus basse possible).

Toute tentative d‚Äôinstancier un Bureaucrat avec une note invalide doit lancer une exception :
soit une Bureaucrat::GradeTooHighException, soit une Bureaucrat::GradeTooLowException.

Vous devez fournir des accesseurs pour les deux attributs : getName() et getGrade().
Vous devez √©galement impl√©menter deux fonctions membres permettant d‚Äôincr√©menter ou de d√©cr√©menter la note du bureaucrate.
Si la note sort des limites autoris√©es, ces fonctions doivent lancer les m√™mes exceptions que le constructeur.

Rappelez-vous que, comme 1 est la note la plus √©lev√©e et 150 la plus basse,
incr√©menter une note de 3 doit aboutir √† une note de 2 pour le bureaucrate.

Les exceptions lev√©es doivent pouvoir √™tre captur√©es avec des blocs try et catch :


try
{
    /* faire des op√©rations avec des bureaucrates */
}
catch (std::exception & e)
{
    /* g√©rer l'exception */
}

Vous devez √©galement surcharger l‚Äôop√©rateur d‚Äôinsertion (<<) afin d‚Äôafficher le r√©sultat dans le format suivant (sans les chevrons) :
<nom>, bureaucrat grade <note>.

Comme toujours, fournissez des tests pour prouver que tout fonctionne comme pr√©vu.

Voici une impl√©mentation compl√®te et simple en C++ de la classe Bureaucrat avec tout ce que demande l‚Äô√©nonc√© :
 exceptions personnalis√©es, getters, gestion des limites, incr√©mentation/d√©cr√©mentation de grade, surcharge de 
 l‚Äôop√©rateur <<, et un exemple de test.

üì¶ Fichier Bureaucrat.hpp

/******************************************************************************************************************** */
#ifndef BUREAUCRAT_HPP
#define BUREAUCRAT_HPP

#include <iostream>
#include <string>
#include <exception>

class Bureaucrat {
private:
    const std::string name;
    int grade;

public:
    Bureaucrat(const std::string& name, int grade);
    ~Bureaucrat();

    const std::string& getName() const;
    int getGrade() const;

    void incrementGrade(); // monte en grade (grade--)
    void decrementGrade(); // descend en grade (grade++)

    class GradeTooHighException : public std::exception {
    public:
        const char* what() const noexcept override;
    };

    class GradeTooLowException : public std::exception {
    public:
        const char* what() const noexcept override;
    };
};

std::ostream& operator<<(std::ostream& out, const Bureaucrat& b);

#endif
‚öôÔ∏è Fichier Bureaucrat.cpp

/******************************************************************************************************************** */
#include "Bureaucrat.hpp"

// Constructeur
Bureaucrat::Bureaucrat(const std::string& name, int grade) : name(name) {
    if (grade < 1)
        throw GradeTooHighException();
    if (grade > 150)
        throw GradeTooLowException();
    this->grade = grade;
}

// Destructeur
Bureaucrat::~Bureaucrat() {}

// Accesseurs
const std::string& Bureaucrat::getName() const {
    return name;
}

int Bureaucrat::getGrade() const {
    return grade;
}

// Incr√©mentation (grade--)
void Bureaucrat::incrementGrade() {
    if (grade <= 1)
        throw GradeTooHighException();
    grade--;
}

// D√©cr√©mentation (grade++)
void Bureaucrat::decrementGrade() {
    if (grade >= 150)
        throw GradeTooLowException();
    grade++;
}

// Exceptions personnalis√©es
const char* Bureaucrat::GradeTooHighException::what() const noexcept {
    return "Grade is too high!";
}

const char* Bureaucrat::GradeTooLowException::what() const noexcept {
    return "Grade is too low!";
}

// Surcharge op√©rateur <<
std::ostream& operator<<(std::ostream& out, const Bureaucrat& b) {
    out << b.getName() << ", bureaucrat grade " << b.getGrade() << ".";
    return out;
}
üß™ Exemple de test ‚Äì Fichier main.cpp

/******************************************************************************************************************** */
#include "Bureaucrat.hpp"

int main() {
    try {
        Bureaucrat a("Alice", 2);
        std::cout << a << std::endl;

        a.incrementGrade();  // Alice passe au grade 1
        std::cout << a << std::endl;

        a.incrementGrade();  // Erreur : grade trop haut
    }
    catch (std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }

    try {
        Bureaucrat b("Bob", 151);  // Erreur √† la construction
    }
    catch (std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }

    return 0;
}
‚úÖ R√©sultat attendu
vbnet
Copier
Modifier
Alice, bureaucrat grade 2.
Alice, bureaucrat grade 1.
Exception: Grade is too high!
Exception: Grade is too low!
Souhaitez-vous qu‚Äôon ajoute d‚Äôautres fonctionnalit√©s, comme la gestion de formulaires ou d‚Äôautres classes associ√©es (par exemple Form) ?







Vous avez dit¬†:
peut on d√©clarer GradeTooHighException et GradeTooLowException en d√©hors de la class Bureaucrat
ChatGPT a dit¬†:
Oui, on peut d√©clarer GradeTooHighException et GradeTooLowException en dehors de la classe Bureaucrat, mais cela a des implications de conception et de lisibilit√©.

‚úÖ 1. Oui techniquement
Voici ce que cela donnerait si on les d√©clarait en dehors :

üìÑ GradeExceptions.hpp

/******************************************************************************************************************** */
#ifndef GRADE_EXCEPTIONS_HPP
#define GRADE_EXCEPTIONS_HPP

#include <exception>

class GradeTooHighException : public std::exception {
public:
    const char* what() const noexcept override;
};

class GradeTooLowException : public std::exception {
public:
    const char* what() const noexcept override;
};

#endif
üìÑ GradeExceptions.cpp

/******************************************************************************************************************** */
#include "GradeExceptions.hpp"

const char* GradeTooHighException::what() const noexcept {
    return "Grade is too high!";
}

const char* GradeTooLowException::what() const noexcept {
    return "Grade is too low!";
}
üìÑ Bureaucrat.hpp

/******************************************************************************************************************** */
#include "GradeExceptions.hpp"

class Bureaucrat {
    // ...
    void incrementGrade();
    void decrementGrade();
};
üìÑ Bureaucrat.cpp

/******************************************************************************************************************** */
#include "Bureaucrat.hpp"

void Bureaucrat::incrementGrade() {
    if (grade <= 1)
        throw GradeTooHighException();
    grade--;
}

void Bureaucrat::decrementGrade() {
    if (grade >= 150)
        throw GradeTooLowException();
    grade++;
}
‚ö†Ô∏è 2. Mais attention c√¥t√© conception
Placer les exceptions √† l‚Äôint√©rieur de la classe permet :

de regrouper logiquement les exceptions sp√©cifiques √† une classe,

de r√©duire la pollution de l‚Äôespace global de noms,

d‚Äôexprimer que ces exceptions n‚Äôont de sens que dans le contexte de Bureaucrat.

C‚Äôest pourquoi on pr√©f√®re souvent les √©crire comme classes imbriqu√©es :


/******************************************************************************************************************** */
class Bureaucrat {
public:
    class GradeTooHighException : public std::exception { ... };
    class GradeTooLowException : public std::exception { ... };
};
‚úÖ En r√©sum√©
D√©claration des exceptions	Avantages	Inconv√©nients
Dans la classe	Encapsulation, clart√©, port√©e limit√©e	Code un peu plus long dans la m√™me classe
En dehors de la classe	R√©utilisable ailleurs, s√©paration des responsabilit√©s	Moins clair que l‚Äôexception est li√©e √† Bureaucrat

üëâ Recommandation : pour ce projet, d√©clare-les √† l‚Äôint√©rieur de Bureaucrat, sauf si tu comptes r√©utiliser les m√™mes exceptions dans plusieurs classes.